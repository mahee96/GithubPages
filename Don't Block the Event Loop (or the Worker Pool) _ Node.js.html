<!DOCTYPE html>
<!-- saved from url=(0060)https://nodejs.org/en/docs/guides/dont-block-the-event-loop/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Don't Block the Event Loop (or the Worker Pool) | Node.js</title>

  <link rel="dns-prefetch" href="https://fonts.googleapis.com/">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com/">
  <link rel="dns-prefetch" href="https://api.github.com/">

  <link rel="stylesheet" href="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/css">
  <link rel="stylesheet" href="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/styles.css">

  <meta name="author" content="Node.js">
  <meta name="robots" content="index, follow">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.">

  <link rel="apple-touch-icon" href="https://nodejs.org/static/images/favicons/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" href="https://nodejs.org/static/images/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
  <link rel="icon" href="https://nodejs.org/static/images/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
  <link rel="manifest" href="https://nodejs.org/static/images/favicons/manifest.json">
  <link rel="mask-icon" href="https://nodejs.org/static/images/favicons/safari-pinned-tab.svg" color="#43853d">
  <link rel="shortcut icon" href="https://nodejs.org/static/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#333333">
  <meta name="msapplication-config" content="/static/images/favicons/browserconfig.xml">
  <meta name="theme-color" content="#333333">

  <meta property="og:site_name" content="Node.js">
  <meta property="og:title" content="Don&#39;t Block the Event Loop (or the Worker Pool) | Node.js">
  <meta property="og:image" content="https://nodejs.org/static/images/logo-hexagon-card.png">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="224">
  <meta property="og:image:height" content="256">
  <meta property="og:description" content="Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nodejs">
  <meta name="twitter:title" content="Don&#39;t Block the Event Loop (or the Worker Pool) | Node.js">
  <meta name="twitter:image" content="https://nodejs.org/static/images/logo-hexagon-card.png">
  <meta name="twitter:image:alt" content="The Node.js Hexagon Logo">

  <link rel="canonical" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/">
  <link rel="alternate" href="https://nodejs.org/en/feed/blog.xml" title="Node.js Blog" type="application/rss+xml">
  <link rel="alternate" href="https://nodejs.org/en/feed/releases.xml" title="Node.js Blog: Releases" type="application/rss+xml">
  <link rel="alternate" href="https://nodejs.org/en/feed/vulnerability.xml" title="Node.js Blog: Vulnerability Reports" type="application/rss+xml">
</head>

<body>
  <header>
    <div class="container">
  
      <a href="https://nodejs.org/en/" id="logo">
        <img src="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/logo.svg" alt="Node.js" width="122" height="75">
      </a>
  
      <nav aria-label="primary">
        <ul class="list-divider-pipe">
          <li>
            <a href="https://nodejs.org/en/">Home</a>
          </li>
  
            <li>
                <a href="https://nodejs.org/en/about/">About</a>
            </li>
            <li>
                <a href="https://nodejs.org/en/download/">Downloads</a>
            </li>
            <li class="active">
                <a href="https://nodejs.org/en/docs/">Docs</a>
            </li>
            <li>
                <a href="https://nodejs.org/en/get-involved/">Get Involved</a>
            </li>
            <li>
                <a href="https://nodejs.org/en/security/">Security</a>
            </li>
            <li>
                <a href="https://openjsf.org/certification">Certification</a>
            </li>
            <li>
                <a href="https://nodejs.org/en/blog/">News</a>
            </li>
        </ul>
      </nav>
  
      <button class="lang-picker-toggler" type="button" aria-controls="lang-picker" aria-expanded="false" title="English">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="25" height="25" aria-hidden="true" focusable="false" fill="currentColor">
          <path d="M217.982 201.586h-64.499c-5.537 0-10.026 4.489-10.026 10.026s4.489 10.026 10.026 10.026h53.547c-4.72 25.263-26.935 44.446-53.547 44.446-30.037 0-54.473-24.436-54.473-54.473s24.436-54.473 54.473-54.473c14.55 0 28.229 5.667 38.518 15.955 3.916 3.916 10.264 3.916 14.178 0 3.916-3.916 3.916-10.264 0-14.178-14.077-14.077-32.791-21.829-52.697-21.829-41.094 0-74.525 33.431-74.525 74.525 0 41.094 33.431 74.525 74.525 74.525s74.525-33.431 74.525-74.525c.001-5.536-4.488-10.025-10.025-10.025z"></path>
          <path d="M470.331 92.24H269.728l-26.935-81.355a10.025 10.025 0 00-9.518-6.875H41.669C18.693 4.01 0 22.703 0 45.679v332.412c0 22.976 18.693 41.669 41.669 41.669h203.145l27.073 81.369a10.026 10.026 0 009.513 6.861h188.932c22.976 0 41.669-18.693 41.669-41.669V133.909c-.001-22.976-18.694-41.669-41.67-41.669zM41.669 399.708c-11.919 0-21.616-9.697-21.616-21.616V45.679c0-11.919 9.697-21.616 21.616-21.616h184.364l70.691 213.516a.366.366 0 00.015.043l53.664 162.086H41.669zm295.78-116.433c.805 1.11 10.824 14.877 26.355 34.066-4.377 5.756-9.015 11.474-13.91 17.036l-29.712-89.74h87.441c-6.196 13.031-16.938 33.813-31.692 55.736-13.553-16.921-22.069-28.622-22.249-28.87-3.251-4.482-9.519-5.481-14.002-2.23-4.482 3.25-5.48 9.518-2.231 14.002zM265.946 419.76h75.162l-55.503 59.084-19.659-59.084zm226.002 46.561c0 11.919-9.697 21.616-21.616 21.616H304.575l67.015-71.339-.004-.003c.293-.312.571-.64.823-.991a10.025 10.025 0 001.39-9.022l-16.688-50.402c7.073-7.406 13.68-15.143 19.805-22.965 13.299 15.772 29.037 33.446 45.778 50.187 1.957 1.957 4.524 2.937 7.089 2.937s5.132-.979 7.089-2.937c3.916-3.916 3.916-10.264 0-14.178-17.461-17.461-34.013-36.244-47.687-52.632 21.251-30.503 35.033-59.504 40.535-71.954h21.454c5.537 0 10.026-4.489 10.026-10.026s-4.489-10.026-10.026-10.026h-66.173v-18.047c0-5.537-4.489-10.026-10.026-10.026s-10.026 4.489-10.026 10.026v18.046h-51.406l-37.178-112.292H470.33c11.919 0 21.616 9.697 21.616 21.616v332.412z"></path>
        </svg>
        <span class="sr-only">Toggle Language</span>
      </button>
  
      <ul id="lang-picker" class="lang-picker hidden">
          <li>
            <button data-lang="ar" title="Arabic">العربية</button>
          </li>
          <li>
            <button data-lang="ca" title="Catalan">Catalan</button>
          </li>
          <li>
            <button data-lang="de" title="German">Deutsch</button>
          </li>
          
          <li>
            <button data-lang="es" title="Spanish">Español</button>
          </li>
          <li>
            <button data-lang="fa" title="Persian">زبان فارسی</button>
          </li>
          <li>
            <button data-lang="fr" title="French">Français</button>
          </li>
          <li>
            <button data-lang="gl" title="Galician">Galego</button>
          </li>
          <li>
            <button data-lang="it" title="Italian">Italiano</button>
          </li>
          <li>
            <button data-lang="ja" title="Japanese">日本語</button>
          </li>
          <li>
            <button data-lang="ko" title="Korean">한국어</button>
          </li>
          <li>
            <button data-lang="pt-br" title="Portuguese, Brazilian">Português do Brasil</button>
          </li>
          <li>
            <button data-lang="ro" title="Romanian">limba română</button>
          </li>
          <li>
            <button data-lang="ru" title="Russian">Русский</button>
          </li>
          <li>
            <button data-lang="tr" title="Turkish">Türkçe</button>
          </li>
          <li>
            <button data-lang="uk" title="Ukrainian">Українська</button>
          </li>
          <li>
            <button data-lang="zh-cn" title="Chinese Simplified">中文(简体)</button>
          </li>
          <li>
            <button data-lang="zh-tw" title="Traditional Chinese">中文 (繁體)</button>
          </li>
      </ul>
  
    </div>
  </header>

  <div id="main">
    <div class="container has-side-nav">

      <nav aria-label="secondary">
        <ul>
                <li>
                      <a href="https://nodejs.org/en/docs/">Docs</a>
                </li>
                <li>
                      <a href="https://nodejs.org/en/docs/es6/">ES6 and beyond</a>
                </li>
                <li>
                      <a href="https://nodejs.org/dist/latest-v14.x/docs/api/">v14.15.5 API <span class="small color-lightgray">LTS</span></a>
                </li>
                <li>
                      <a href="https://nodejs.org/dist/latest-v15.x/docs/api/">v15.8.0 API</a>
                </li>
                <li>
                      <a href="https://nodejs.org/en/docs/guides/">Guides</a>
                </li>
                <li>
                      <a href="https://nodejs.org/en/docs/meta/topics/dependencies/">Dependencies</a>
                </li>
        </ul>
      </nav>

      <article>
        <a class="edit-link" href="https://github.com/nodejs/nodejs.org/edit/master/locale/en/docs/guides/dont-block-the-event-loop.md">Edit on GitHub</a> <h1 id="header-don-t-block-the-event-loop-or-the-worker-pool">Don't Block the Event Loop (or the Worker Pool)<a id="don-t-block-the-event-loop-or-the-worker-pool" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#don-t-block-the-event-loop-or-the-worker-pool" aria-labelledby="header-don-t-block-the-event-loop-or-the-worker-pool"></a></h1><h2 id="header-should-you-read-this-guide">Should you read this guide?<a id="should-you-read-this-guide" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#should-you-read-this-guide" aria-labelledby="header-should-you-read-this-guide"></a></h2><p>If you're writing anything more complicated than a brief command-line script, reading this should help you write higher-performance, more-secure applications.</p>
<p>This document is written with Node.js servers in mind, but the concepts apply to complex Node.js applications as well.
Where OS-specific details vary, this document is Linux-centric.</p>
<h2 id="header-summary">Summary<a id="summary" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#summary" aria-labelledby="header-summary"></a></h2><p>Node.js runs JavaScript code in the Event Loop (initialization and callbacks), and offers a Worker Pool to handle expensive tasks like file I/O.
Node.js scales well, sometimes better than more heavyweight approaches like Apache.
The secret to the scalability of Node.js is that it uses a small number of threads to handle many clients.
If Node.js can make do with fewer threads, then it can spend more of your system's time and memory working on clients rather than on paying space and time overheads for threads (memory, context-switching).
But because Node.js has only a few threads, you must structure your application to use them wisely.</p>
<p>Here's a good rule of thumb for keeping your Node.js server speedy:
<em>Node.js is fast when the work associated with each client at any given time is "small"</em>.</p>
<p>This applies to callbacks on the Event Loop and tasks on the Worker Pool.</p>
<h2 id="header-why-should-i-avoid-blocking-the-event-loop-and-the-worker-pool">Why should I avoid blocking the Event Loop and the Worker Pool?<a id="why-should-i-avoid-blocking-the-event-loop-and-the-worker-pool" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#why-should-i-avoid-blocking-the-event-loop-and-the-worker-pool" aria-labelledby="header-why-should-i-avoid-blocking-the-event-loop-and-the-worker-pool"></a></h2><p>Node.js uses a small number of threads to handle many clients.
In Node.js there are two types of threads: one Event Loop (aka the main loop, main thread, event thread, etc.), and a pool of <code>k</code> Workers in a Worker Pool (aka the threadpool).</p>
<p>If a thread is taking a long time to execute a callback (Event Loop) or a task (Worker), we call it "blocked".
While a thread is blocked working on behalf of one client, it cannot handle requests from any other clients.
This provides two motivations for blocking neither the Event Loop nor the Worker Pool:</p>
<ol>
<li>Performance: If you regularly perform heavyweight activity on either type of thread, the <em>throughput</em> (requests/second) of your server will suffer.</li>
<li>Security: If it is possible that for certain input one of your threads might block, a malicious client could submit this "evil input", make your threads block, and keep them from working on other clients. This would be a <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">Denial of Service</a> attack.</li>
</ol>
<h2 id="header-a-quick-review-of-node">A quick review of Node<a id="a-quick-review-of-node" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#a-quick-review-of-node" aria-labelledby="header-a-quick-review-of-node"></a></h2><p>Node.js uses the Event-Driven Architecture: it has an Event Loop for orchestration and a Worker Pool for expensive tasks.</p>
<h3 id="header-what-code-runs-on-the-event-loop">What code runs on the Event Loop?<a id="what-code-runs-on-the-event-loop" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#what-code-runs-on-the-event-loop" aria-labelledby="header-what-code-runs-on-the-event-loop"></a></h3><p>When they begin, Node.js applications first complete an initialization phase, <code>require</code>'ing modules and registering callbacks for events.
Node.js applications then enter the Event Loop, responding to incoming client requests by executing the appropriate callback.
This callback executes synchronously, and may register asynchronous requests to continue processing after it completes.
The callbacks for these asynchronous requests will also be executed on the Event Loop.</p>
<p>The Event Loop will also fulfill the non-blocking asynchronous requests made by its callbacks, e.g., network I/O.</p>
<p>In summary, the Event Loop executes the JavaScript callbacks registered for events, and is also responsible for fulfilling non-blocking asynchronous requests like network I/O.</p>
<h3 id="header-what-code-runs-on-the-worker-pool">What code runs on the Worker Pool?<a id="what-code-runs-on-the-worker-pool" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#what-code-runs-on-the-worker-pool" aria-labelledby="header-what-code-runs-on-the-worker-pool"></a></h3><p>The Worker Pool of Node.js is implemented in libuv (<a href="http://docs.libuv.org/en/v1.x/threadpool.html">docs</a>), which exposes a general task submission API.</p>
<p>Node.js uses the Worker Pool to handle "expensive" tasks.
This includes I/O for which an operating system does not provide a non-blocking version, as well as particularly CPU-intensive tasks.</p>
<p>These are the Node.js module APIs that make use of this Worker Pool:</p>
<ol>
<li>I/O-intensive<ol>
<li><a href="https://nodejs.org/api/dns.html">DNS</a>: <code>dns.lookup()</code>, <code>dns.lookupService()</code>.</li>
<li><a href="https://nodejs.org/api/fs.html#fs_threadpool_usage">File System</a>: All file system APIs except <code>fs.FSWatcher()</code> and those that are explicitly synchronous use libuv's threadpool.</li>
</ol>
</li>
<li>CPU-intensive<ol>
<li><a href="https://nodejs.org/api/crypto.html">Crypto</a>: <code>crypto.pbkdf2()</code>, <code>crypto.scrypt()</code>, <code>crypto.randomBytes()</code>, <code>crypto.randomFill()</code>, <code>crypto.generateKeyPair()</code>.</li>
<li><a href="https://nodejs.org/api/zlib.html#zlib_threadpool_usage">Zlib</a>: All zlib APIs except those that are explicitly synchronous use libuv's threadpool.</li>
</ol>
</li>
</ol>
<p>In many Node.js applications, these APIs are the only sources of tasks for the Worker Pool. Applications and modules that use a <a href="https://nodejs.org/api/addons.html">C++ add-on</a> can submit other tasks to the Worker Pool.</p>
<p>For the sake of completeness, we note that when you call one of these APIs from a callback on the Event Loop, the Event Loop pays some minor setup costs as it enters the Node.js C++ bindings for that API and submits a task to the Worker Pool.
These costs are negligible compared to the overall cost of the task, which is why the Event Loop is offloading it.
When submitting one of these tasks to the Worker Pool, Node.js provides a pointer to the corresponding C++ function in the Node.js C++ bindings.</p>
<h3 id="header-how-does-node-js-decide-what-code-to-run-next">How does Node.js decide what code to run next?<a id="how-does-node-js-decide-what-code-to-run-next" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#how-does-node-js-decide-what-code-to-run-next" aria-labelledby="header-how-does-node-js-decide-what-code-to-run-next"></a></h3><p>Abstractly, the Event Loop and the Worker Pool maintain queues for pending events and pending tasks, respectively.</p>
<p>In truth, the Event Loop does not actually maintain a queue.
Instead, it has a collection of file descriptors that it asks the operating system to monitor, using a mechanism like <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> (Linux), <a href="https://developer.apple.com/library/content/documentation/Darwin/Conceptual/FSEvents_ProgGuide/KernelQueues/KernelQueues.html">kqueue</a> (OSX), event ports (Solaris), or <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx">IOCP</a> (Windows).
These file descriptors correspond to network sockets, any files it is watching, and so on.
When the operating system says that one of these file descriptors is ready, the Event Loop translates it to the appropriate event and invokes the callback(s) associated with that event.
You can learn more about this process <a href="https://www.youtube.com/watch?v=P9csgxBgaZ8">here</a>.</p>
<p>In contrast, the Worker Pool uses a real queue whose entries are tasks to be processed.
A Worker pops a task from this queue and works on it, and when finished the Worker raises an "At least one task is finished" event for the Event Loop.</p>
<h3 id="header-what-does-this-mean-for-application-design">What does this mean for application design?<a id="what-does-this-mean-for-application-design" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#what-does-this-mean-for-application-design" aria-labelledby="header-what-does-this-mean-for-application-design"></a></h3><p>In a one-thread-per-client system like Apache, each pending client is assigned its own thread.
If a thread handling one client blocks, the operating system will interrupt it and give another client a turn.
The operating system thus ensures that clients that require a small amount of work are not penalized by clients that require more work.</p>
<p>Because Node.js handles many clients with few threads, if a thread blocks handling one client's request, then pending client requests may not get a turn until the thread finishes its callback or task.
<em>The fair treatment of clients is thus the responsibility of your application</em>.
This means that you shouldn't do too much work for any client in any single callback or task.</p>
<p>This is part of why Node.js can scale well, but it also means that you are responsible for ensuring fair scheduling.
The next sections talk about how to ensure fair scheduling for the Event Loop and for the Worker Pool.</p>
<h2 id="header-don-t-block-the-event-loop">Don't block the Event Loop<a id="don-t-block-the-event-loop" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#don-t-block-the-event-loop" aria-labelledby="header-don-t-block-the-event-loop"></a></h2><p>The Event Loop notices each new client connection and orchestrates the generation of a response.
All incoming requests and outgoing responses pass through the Event Loop.
This means that if the Event Loop spends too long at any point, all current and new clients will not get a turn.</p>
<p>You should make sure you never block the Event Loop.
In other words, each of your JavaScript callbacks should complete quickly.
This of course also applies to your <code>await</code>'s, your <code>Promise.then</code>'s, and so on.</p>
<p>A good way to ensure this is to reason about the <a href="https://en.wikipedia.org/wiki/Time_complexity">"computational complexity"</a> of your callbacks.
If your callback takes a constant number of steps no matter what its arguments are, then you'll always give every pending client a fair turn.
If your callback takes a different number of steps depending on its arguments, then you should think about how long the arguments might be.</p>
<p>Example 1: A constant-time callback.</p>
<pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/constant-time'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">sendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Example 2: An <code>O(n)</code> callback. This callback will run quickly for small <code>n</code> and more slowly for large <code>n</code>.</p>
<pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/countToN'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>n<span class="token punctuation">;</span>

  <span class="token comment">// n iterations before giving someone else a turn</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Iter </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  res<span class="token punctuation">.</span><span class="token function">sendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Example 3: An <code>O(n^2)</code> callback. This callback will still run quickly for small <code>n</code>, but for large <code>n</code> it will run much more slowly than the previous <code>O(n)</code> example.</p>
<pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/countToN2'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>n<span class="token punctuation">;</span>

  <span class="token comment">// n^2 iterations before giving someone else a turn</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Iter </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  res<span class="token punctuation">.</span><span class="token function">sendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="header-how-careful-should-you-be">How careful should you be?<a id="how-careful-should-you-be" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#how-careful-should-you-be" aria-labelledby="header-how-careful-should-you-be"></a></h3><p>Node.js uses the Google V8 engine for JavaScript, which is quite fast for many common operations.
Exceptions to this rule are regexps and JSON operations, discussed below.</p>
<p>However, for complex tasks you should consider bounding the input and rejecting inputs that are too long.
That way, even if your callback has large complexity, by bounding the input you ensure the callback cannot take more than the worst-case time on the longest acceptable input.
You can then evaluate the worst-case cost of this callback and determine whether its running time is acceptable in your context.</p>
<h3 id="header-blocking-the-event-loop-redos">Blocking the Event Loop: REDOS<a id="blocking-the-event-loop-redos" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#blocking-the-event-loop-redos" aria-labelledby="header-blocking-the-event-loop-redos"></a></h3><p>One common way to block the Event Loop disastrously is by using a "vulnerable" <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">regular expression</a>.</p>
<h4 id="header-avoiding-vulnerable-regular-expressions">Avoiding vulnerable regular expressions<a id="avoiding-vulnerable-regular-expressions" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#avoiding-vulnerable-regular-expressions" aria-labelledby="header-avoiding-vulnerable-regular-expressions"></a></h4><p>A regular expression (regexp) matches an input string against a pattern.
We usually think of a regexp match as requiring a single pass through the input string --- <code>O(n)</code> time where <code>n</code> is the length of the input string.
In many cases, a single pass is indeed all it takes.
Unfortunately, in some cases the regexp match might require an exponential number of trips through the input string --- <code>O(2^n)</code> time.
An exponential number of trips means that if the engine requires <code>x</code> trips to determine a match, it will need <code>2*x</code> trips if we add only one more character to the input string.
Since the number of trips is linearly related to the time required, the effect of this evaluation will be to block the Event Loop.</p>
<p>A <em>vulnerable regular expression</em> is one on which your regular expression engine might take exponential time, exposing you to <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">REDOS</a> on "evil input".
Whether or not your regular expression pattern is vulnerable (i.e. the regexp engine might take exponential time on it) is actually a difficult question to answer, and varies depending on whether you're using Perl, Python, Ruby, Java, JavaScript, etc., but here are some rules of thumb that apply across all of these languages:</p>
<ol>
<li>Avoid nested quantifiers like <code>(a+)*</code>. V8's regexp engine can handle some of these quickly, but others are vulnerable.</li>
<li>Avoid OR's with overlapping clauses, like <code>(a|a)*</code>. Again, these are sometimes-fast.</li>
<li>Avoid using backreferences, like <code>(a.*) \1</code>. No regexp engine can guarantee evaluating these in linear time.</li>
<li>If you're doing a simple string match, use <code>indexOf</code> or the local equivalent. It will be cheaper and will never take more than <code>O(n)</code>.</li>
</ol>
<p>If you aren't sure whether your regular expression is vulnerable, remember that Node.js generally doesn't have trouble reporting a <em>match</em> even for a vulnerable regexp and a long input string.
The exponential behavior is triggered when there is a mismatch but Node.js can't be certain until it tries many paths through the input string.</p>
<h4 id="header-a-redos-example">A REDOS example<a id="a-redos-example" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#a-redos-example" aria-labelledby="header-a-redos-example"></a></h4><p>Here is an example vulnerable regexp exposing its server to REDOS:</p>
<pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/redos-me'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> filePath <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filePath<span class="token punctuation">;</span>

  <span class="token comment">// REDOS</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/(\/.+)+$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'valid path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'invalid path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  res<span class="token punctuation">.</span><span class="token function">sendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The vulnerable regexp in this example is a (bad!) way to check for a valid path on Linux.
It matches strings that are a sequence of "/"-delimited names, like "/a/b/c".
It is dangerous because it violates rule 1: it has a doubly-nested quantifier.</p>
<p>If a client queries with filePath <code>///.../\n</code> (100 /'s followed by a newline character that the regexp's "." won't match), then the Event Loop will take effectively forever, blocking the Event Loop.
This client's REDOS attack causes all other clients not to get a turn until the regexp match finishes.</p>
<p>For this reason, you should be leery of using complex regular expressions to validate user input.</p>
<h4 id="header-anti-redos-resources">Anti-REDOS Resources<a id="anti-redos-resources" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#anti-redos-resources" aria-labelledby="header-anti-redos-resources"></a></h4><p>There are some tools to check your regexps for safety, like</p>
<ul>
<li><a href="https://github.com/substack/safe-regex">safe-regex</a></li>
<li><a href="http://www.cs.bham.ac.uk/~hxt/research/rxxr2/">rxxr2</a>.
However, neither of these will catch all vulnerable regexps.</li>
</ul>
<p>Another approach is to use a different regexp engine.
You could use the <a href="https://github.com/uhop/node-re2">node-re2</a> module, which uses Google's blazing-fast <a href="https://github.com/google/re2">RE2</a> regexp engine.
But be warned, RE2 is not 100% compatible with V8's regexps, so check for regressions if you swap in the node-re2 module to handle your regexps.
And particularly complicated regexps are not supported by node-re2.</p>
<p>If you're trying to match something "obvious", like a URL or a file path, find an example in a <a href="http://www.regexlib.com/">regexp library</a> or use an npm module, e.g. <a href="https://www.npmjs.com/package/ip-regex">ip-regex</a>.</p>
<h3 id="header-blocking-the-event-loop-node-js-core-modules">Blocking the Event Loop: Node.js core modules<a id="blocking-the-event-loop-node-js-core-modules" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#blocking-the-event-loop-node-js-core-modules" aria-labelledby="header-blocking-the-event-loop-node-js-core-modules"></a></h3><p>Several Node.js core modules have synchronous expensive APIs, including:</p>
<ul>
<li><a href="https://nodejs.org/api/crypto.html">Encryption</a></li>
<li><a href="https://nodejs.org/api/zlib.html">Compression</a></li>
<li><a href="https://nodejs.org/api/fs.html">File system</a></li>
<li><a href="https://nodejs.org/api/child_process.html">Child process</a></li>
</ul>
<p>These APIs are expensive, because they involve significant computation (encryption, compression), require I/O (file I/O), or potentially both (child process). These APIs are intended for scripting convenience, but are not intended for use in the server context. If you execute them on the Event Loop, they will take far longer to complete than a typical JavaScript instruction, blocking the Event Loop.</p>
<p>In a server, <em>you should not use the following synchronous APIs from these modules</em>:</p>
<ul>
<li>Encryption:<ul>
<li><code>crypto.randomBytes</code> (synchronous version)</li>
<li><code>crypto.randomFillSync</code></li>
<li><code>crypto.pbkdf2Sync</code></li>
<li>You should also be careful about providing large input to the encryption and decryption routines.</li>
</ul>
</li>
<li>Compression:<ul>
<li><code>zlib.inflateSync</code></li>
<li><code>zlib.deflateSync</code></li>
</ul>
</li>
<li>File system:<ul>
<li>Do not use the synchronous file system APIs. For example, if the file you access is in a <a href="https://en.wikipedia.org/wiki/Clustered_file_system#Distributed_file_systems">distributed file system</a> like <a href="https://en.wikipedia.org/wiki/Network_File_System">NFS</a>, access times can vary widely.</li>
</ul>
</li>
<li>Child process:<ul>
<li><code>child_process.spawnSync</code></li>
<li><code>child_process.execSync</code></li>
<li><code>child_process.execFileSync</code></li>
</ul>
</li>
</ul>
<p>This list is reasonably complete as of Node.js v9.</p>
<h3 id="header-blocking-the-event-loop-json-dos">Blocking the Event Loop: JSON DOS<a id="blocking-the-event-loop-json-dos" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#blocking-the-event-loop-json-dos" aria-labelledby="header-blocking-the-event-loop-json-dos"></a></h3><p><code>JSON.parse</code> and <code>JSON.stringify</code> are other potentially expensive operations.
While these are <code>O(n)</code> in the length of the input, for large <code>n</code> they can take surprisingly long.</p>
<p>If your server manipulates JSON objects, particularly those from a client, you should be cautious about the size of the objects or strings you work with on the Event Loop.</p>
<p>Example: JSON blocking. We create an object <code>obj</code> of size 2^21 and <code>JSON.stringify</code> it, run <code>indexOf</code> on the string, and then JSON.parse it. The <code>JSON.stringify</code>'d string is 50MB. It takes 0.7 seconds to stringify the object, 0.03 seconds to indexOf on the 50MB string, and 1.3 seconds to parse the string.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> niter <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> before<span class="token punctuation">,</span> str<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> res<span class="token punctuation">,</span> took<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> niter<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj <span class="token operator">=</span> <span class="token punctuation">{</span> obj1<span class="token operator">:</span> obj<span class="token punctuation">,</span> obj2<span class="token operator">:</span> obj <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Doubles in size each iter</span>
<span class="token punctuation">}</span>

before <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
took <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span>before<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'JSON.stringify took '</span> <span class="token operator">+</span> took<span class="token punctuation">)</span><span class="token punctuation">;</span>

before <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pos <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'nomatch'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
took <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span>before<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Pure indexof took '</span> <span class="token operator">+</span> took<span class="token punctuation">)</span><span class="token punctuation">;</span>

before <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
took <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">hrtime</span><span class="token punctuation">(</span>before<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'JSON.parse took '</span> <span class="token operator">+</span> took<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>There are npm modules that offer asynchronous JSON APIs. See for example:</p>
<ul>
<li><a href="https://www.npmjs.com/package/JSONStream">JSONStream</a>, which has stream APIs.</li>
<li><a href="https://www.npmjs.com/package/bfj">Big-Friendly JSON</a>, which has stream APIs as well as asynchronous versions of the standard JSON APIs using the partitioning-on-the-Event-Loop paradigm outlined below.</li>
</ul>
<h3 id="header-complex-calculations-without-blocking-the-event-loop">Complex calculations without blocking the Event Loop<a id="complex-calculations-without-blocking-the-event-loop" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#complex-calculations-without-blocking-the-event-loop" aria-labelledby="header-complex-calculations-without-blocking-the-event-loop"></a></h3><p>Suppose you want to do complex calculations in JavaScript without blocking the Event Loop.
You have two options: partitioning or offloading.</p>
<h4 id="header-partitioning">Partitioning<a id="partitioning" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#partitioning" aria-labelledby="header-partitioning"></a></h4><p>You could <em>partition</em> your calculations so that each runs on the Event Loop but regularly yields (gives turns to) other pending events.
In JavaScript it's easy to save the state of an ongoing task in a closure, as shown in example 2 below.</p>
<p>For a simple example, suppose you want to compute the average of the numbers <code>1</code> to <code>n</code>.</p>
<p>Example 1: Un-partitioned average, costs <code>O(n)</code></p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
<span class="token keyword">let</span> avg <span class="token operator">=</span> sum <span class="token operator">/</span> n<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'avg: '</span> <span class="token operator">+</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Example 2: Partitioned average, each of the <code>n</code> asynchronous steps costs <code>O(1)</code>.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">asyncAvg</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> avgCB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Save ongoing sum in JS closure.</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cb</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// "Asynchronous recursion".</span>
    <span class="token comment">// Schedule next operation asynchronously.</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token function">help</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Start the helper, with CB to call avgCB.</span>
  <span class="token function">help</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> avg <span class="token operator">=</span> sum<span class="token operator">/</span>n<span class="token punctuation">;</span>
      <span class="token function">avgCB</span><span class="token punctuation">(</span>avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">asyncAvg</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">avg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'avg of 1-n: '</span> <span class="token operator">+</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>You can apply this principle to array iterations and so forth.</p>
<h4 id="header-offloading">Offloading<a id="offloading" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#offloading" aria-labelledby="header-offloading"></a></h4><p>If you need to do something more complex, partitioning is not a good option.
This is because partitioning uses only the Event Loop, and you won't benefit from multiple cores almost certainly available on your machine.
<em>Remember, the Event Loop should orchestrate client requests, not fulfill them itself.</em>
For a complicated task, move the work off of the Event Loop onto a Worker Pool.</p>
<h5 id="header-how-to-offload">How to offload<a id="how-to-offload" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#how-to-offload" aria-labelledby="header-how-to-offload"></a></h5><p>You have two options for a destination Worker Pool to which to offload work.</p>
<ol>
<li>You can use the built-in Node.js Worker Pool by developing a <a href="https://nodejs.org/api/addons.html">C++ addon</a>. On older versions of Node, build your C++ addon using <a href="https://github.com/nodejs/nan">NAN</a>, and on newer versions use <a href="https://nodejs.org/api/n-api.html">N-API</a>. <a href="https://www.npmjs.com/package/webworker-threads">node-webworker-threads</a> offers a JavaScript-only way to access the Node.js Worker Pool.</li>
<li>You can create and manage your own Worker Pool dedicated to computation rather than the Node.js I/O-themed Worker Pool. The most straightforward ways to do this is using <a href="https://nodejs.org/api/child_process.html">Child Process</a> or <a href="https://nodejs.org/api/cluster.html">Cluster</a>.</li>
</ol>
<p>You should <em>not</em> simply create a <a href="https://nodejs.org/api/child_process.html">Child Process</a> for every client.
You can receive client requests more quickly than you can create and manage children, and your server might become a <a href="https://en.wikipedia.org/wiki/Fork_bomb">fork bomb</a>.</p>
<h5 id="header-downside-of-offloading">Downside of offloading<a id="downside-of-offloading" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#downside-of-offloading" aria-labelledby="header-downside-of-offloading"></a></h5><p>The downside of the offloading approach is that it incurs overhead in the form of <em>communication costs</em>.
Only the Event Loop is allowed to see the "namespace" (JavaScript state) of your application.
From a Worker, you cannot manipulate a JavaScript object in the Event Loop's namespace.
Instead, you have to serialize and deserialize any objects you wish to share.
Then the Worker can operate on its own copy of these object(s) and return the modified object (or a "patch") to the Event Loop.</p>
<p>For serialization concerns, see the section on JSON DOS.</p>
<h5 id="header-some-suggestions-for-offloading">Some suggestions for offloading<a id="some-suggestions-for-offloading" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#some-suggestions-for-offloading" aria-labelledby="header-some-suggestions-for-offloading"></a></h5><p>You may wish to distinguish between CPU-intensive and I/O-intensive tasks because they have markedly different characteristics.</p>
<p>A CPU-intensive task only makes progress when its Worker is scheduled, and the Worker must be scheduled onto one of your machine's <a href="https://nodejs.org/api/os.html#os_os_cpus">logical cores</a>.
If you have 4 logical cores and 5 Workers, one of these Workers cannot make progress.
As a result, you are paying overhead (memory and scheduling costs) for this Worker and getting no return for it.</p>
<p>I/O-intensive tasks involve querying an external service provider (DNS, file system, etc.) and waiting for its response.
While a Worker with an I/O-intensive task is waiting for its response, it has nothing else to do and can be de-scheduled by the operating system, giving another Worker a chance to submit their request.
Thus, <em>I/O-intensive tasks will be making progress even while the associated thread is not running</em>.
External service providers like databases and file systems have been highly optimized to handle many pending requests concurrently.
For example, a file system will examine a large set of pending write and read requests to merge conflicting updates and to retrieve files in an optimal order (e.g. see <a href="http://researcher.ibm.com/researcher/files/il-AVISHAY/01-block_io-v1.3.pdf">these slides</a>).</p>
<p>If you rely on only one Worker Pool, e.g. the Node.js Worker Pool, then the differing characteristics of CPU-bound and I/O-bound work may harm your application's performance.</p>
<p>For this reason, you might wish to maintain a separate Computation Worker Pool.</p>
<h4 id="header-offloading-conclusions">Offloading: conclusions<a id="offloading-conclusions" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#offloading-conclusions" aria-labelledby="header-offloading-conclusions"></a></h4><p>For simple tasks, like iterating over the elements of an arbitrarily long array, partitioning might be a good option.
If your computation is more complex, offloading is a better approach: the communication costs, i.e. the overhead of passing serialized objects between the Event Loop and the Worker Pool, are offset by the benefit of using multiple cores.</p>
<p>However, if your server relies heavily on complex calculations, you should think about whether Node.js is really a good fit. Node.js excels for I/O-bound work, but for expensive computation it might not be the best option.</p>
<p>If you take the offloading approach, see the section on not blocking the Worker Pool.</p>
<h2 id="header-don-t-block-the-worker-pool">Don't block the Worker Pool<a id="don-t-block-the-worker-pool" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#don-t-block-the-worker-pool" aria-labelledby="header-don-t-block-the-worker-pool"></a></h2><p>Node.js has a Worker Pool composed of <code>k</code> Workers.
If you are using the Offloading paradigm discussed above, you might have a separate Computational Worker Pool, to which the same principles apply.
In either case, let us assume that <code>k</code> is much smaller than the number of clients you might be handling concurrently.
This is in keeping with the "one thread for many clients" philosophy of Node.js, the secret to its scalability.</p>
<p>As discussed above, each Worker completes its current Task before proceeding to the next one on the Worker Pool queue.</p>
<p>Now, there will be variation in the cost of the Tasks required to handle your clients' requests.
Some Tasks can be completed quickly (e.g. reading short or cached files, or producing a small number of random bytes), and others will take longer (e.g reading larger or uncached files, or generating more random bytes).
Your goal should be to <em>minimize the variation in Task times</em>, and you should use <em>Task partitioning</em> to accomplish this.</p>
<h3 id="header-minimizing-the-variation-in-task-times">Minimizing the variation in Task times<a id="minimizing-the-variation-in-task-times" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#minimizing-the-variation-in-task-times" aria-labelledby="header-minimizing-the-variation-in-task-times"></a></h3><p>If a Worker's current Task is much more expensive than other Tasks, then it will be unavailable to work on other pending Tasks.
In other words, <em>each relatively long Task effectively decreases the size of the Worker Pool by one until it is completed</em>.
This is undesirable because, up to a point, the more Workers in the Worker Pool, the greater the Worker Pool throughput (tasks/second) and thus the greater the server throughput (client requests/second).
One client with a relatively expensive Task will decrease the throughput of the Worker Pool, in turn decreasing the throughput of the server.</p>
<p>To avoid this, you should try to minimize variation in the length of Tasks you submit to the Worker Pool.
While it is appropriate to treat the external systems accessed by your I/O requests (DB, FS, etc.) as black boxes, you should be aware of the relative cost of these I/O requests, and should avoid submitting requests you can expect to be particularly long.</p>
<p>Two examples should illustrate the possible variation in task times.</p>
<h4 id="header-variation-example-long-running-file-system-reads">Variation example: Long-running file system reads<a id="variation-example-long-running-file-system-reads" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#variation-example-long-running-file-system-reads" aria-labelledby="header-variation-example-long-running-file-system-reads"></a></h4><p>Suppose your server must read files in order to handle some client requests.
After consulting the Node.js <a href="https://nodejs.org/api/fs.html">File system</a> APIs, you opted to use <code>fs.readFile()</code> for simplicity.
However, <code>fs.readFile()</code> is (<a href="https://github.com/nodejs/node/pull/17054">currently</a>) not partitioned: it submits a single <code>fs.read()</code> Task spanning the entire file.
If you read shorter files for some users and longer files for others, <code>fs.readFile()</code> may introduce significant variation in Task lengths, to the detriment of Worker Pool throughput.</p>
<p>For a worst-case scenario, suppose an attacker can convince your server to read an <em>arbitrary</em> file (this is a <a href="https://www.owasp.org/index.php/Path_Traversal">directory traversal vulnerability</a>).
If your server is running Linux, the attacker can name an extremely slow file: <a href="http://man7.org/linux/man-pages/man4/random.4.html"><code>/dev/random</code></a>.
For all practical purposes, <code>/dev/random</code> is infinitely slow, and every Worker asked to read from <code>/dev/random</code> will never finish that Task.
An attacker then submits <code>k</code> requests, one for each Worker, and no other client requests that use the Worker Pool will make progress.</p>
<h4 id="header-variation-example-long-running-crypto-operations">Variation example: Long-running crypto operations<a id="variation-example-long-running-crypto-operations" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#variation-example-long-running-crypto-operations" aria-labelledby="header-variation-example-long-running-crypto-operations"></a></h4><p>Suppose your server generates cryptographically secure random bytes using <a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback"><code>crypto.randomBytes()</code></a>.
<code>crypto.randomBytes()</code> is not partitioned: it creates a single <code>randomBytes()</code> Task to generate as many bytes as you requested.
If you create fewer bytes for some users and more bytes for others, <code>crypto.randomBytes()</code> is another source of variation in Task lengths.</p>
<h3 id="header-task-partitioning">Task partitioning<a id="task-partitioning" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#task-partitioning" aria-labelledby="header-task-partitioning"></a></h3><p>Tasks with variable time costs can harm the throughput of the Worker Pool.
To minimize variation in Task times, as far as possible you should <em>partition</em> each Task into comparable-cost sub-Tasks.
When each sub-Task completes it should submit the next sub-Task, and when the final sub-Task completes it should notify the submitter.</p>
<p>To continue the <code>fs.readFile()</code> example, you should instead use <code>fs.read()</code> (manual partitioning) or <code>ReadStream</code> (automatically partitioned).</p>
<p>The same principle applies to CPU-bound tasks; the <code>asyncAvg</code> example might be inappropriate for the Event Loop, but it is well suited to the Worker Pool.</p>
<p>When you partition a Task into sub-Tasks, shorter Tasks expand into a small number of sub-Tasks, and longer Tasks expand into a larger number of sub-Tasks.
Between each sub-Task of a longer Task, the Worker to which it was assigned can work on a sub-Task from another, shorter, Task, thus improving the overall Task throughput of the Worker Pool.</p>
<p>Note that the number of sub-Tasks completed is not a useful metric for the throughput of the Worker Pool.
Instead, concern yourself with the number of <em>Tasks</em> completed.</p>
<h3 id="header-avoiding-task-partitioning">Avoiding Task partitioning<a id="avoiding-task-partitioning" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#avoiding-task-partitioning" aria-labelledby="header-avoiding-task-partitioning"></a></h3><p>Recall that the purpose of Task partitioning is to minimize the variation in Task times.
If you can distinguish between shorter Tasks and longer Tasks (e.g. summing an array vs. sorting an array), you could create one Worker Pool for each class of Task.
Routing shorter Tasks and longer Tasks to separate Worker Pools is another way to minimize Task time variation.</p>
<p>In favor of this approach, partitioning Tasks incurs overhead (the costs of creating a Worker Pool Task representation and of manipulating the Worker Pool queue), and avoiding partitioning saves you the costs of additional trips to the Worker Pool.
It also keeps you from making mistakes in partitioning your Tasks.</p>
<p>The downside of this approach is that Workers in all of these Worker Pools will incur space and time overheads and will compete with each other for CPU time.
Remember that each CPU-bound Task makes progress only while it is scheduled.
As a result, you should only consider this approach after careful analysis.</p>
<h3 id="header-worker-pool-conclusions">Worker Pool: conclusions<a id="worker-pool-conclusions" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#worker-pool-conclusions" aria-labelledby="header-worker-pool-conclusions"></a></h3><p>Whether you use only the Node.js Worker Pool or maintain separate Worker Pool(s), you should optimize the Task throughput of your Pool(s).</p>
<p>To do this, minimize the variation in Task times by using Task partitioning.</p>
<h2 id="header-the-risks-of-npm-modules">The risks of npm modules<a id="the-risks-of-npm-modules" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#the-risks-of-npm-modules" aria-labelledby="header-the-risks-of-npm-modules"></a></h2><p>While the Node.js core modules offer building blocks for a wide variety of applications, sometimes something more is needed. Node.js developers benefit tremendously from the <a href="https://www.npmjs.com/">npm ecosystem</a>, with hundreds of thousands of modules offering functionality to accelerate your development process.</p>
<p>Remember, however, that the majority of these modules are written by third-party developers and are generally released with only best-effort guarantees. A developer using an npm module should be concerned about two things, though the latter is frequently forgotten.</p>
<ol>
<li>Does it honor its APIs?</li>
<li>Might its APIs block the Event Loop or a Worker?
Many modules make no effort to indicate the cost of their APIs, to the detriment of the community.</li>
</ol>
<p>For simple APIs you can estimate the cost of the APIs; the cost of string manipulation isn't hard to fathom.
But in many cases it's unclear how much an API might cost.</p>
<p><em>If you are calling an API that might do something expensive, double-check the cost. Ask the developers to document it, or examine the source code yourself (and submit a PR documenting the cost).</em></p>
<p>Remember, even if the API is asynchronous, you don't know how much time it might spend on a Worker or on the Event Loop in each of its partitions.
For example, suppose in the <code>asyncAvg</code> example given above, each call to the helper function summed <em>half</em> of the numbers rather than one of them.
Then this function would still be asynchronous, but the cost of each partition would be <code>O(n)</code>, not <code>O(1)</code>, making it much less safe to use for arbitrary values of <code>n</code>.</p>
<h2 id="header-conclusion">Conclusion<a id="conclusion" class="anchor" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#conclusion" aria-labelledby="header-conclusion"></a></h2><p>Node.js has two types of threads: one Event Loop and <code>k</code> Workers.
The Event Loop is responsible for JavaScript callbacks and non-blocking I/O, and a Worker executes tasks corresponding to C++ code that completes an asynchronous request, including blocking I/O and CPU-intensive work.
Both types of threads work on no more than one activity at a time.
If any callback or task takes a long time, the thread running it becomes <em>blocked</em>.
If your application makes blocking callbacks or tasks, this can lead to degraded throughput (clients/second) at best, and complete denial of service at worst.</p>
<p>To write a high-throughput, more DoS-proof web server, you must ensure that on benign and on malicious input, neither your Event Loop nor your Workers will block.</p>


      </article>

    </div>
  </div>

  <a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#" id="scroll-to-top" style="display: block;">↑ <span>Scroll to top</span></a>
  
  <footer>
  
    <div class="container">
      <div class="openjsfoundation-footer">
        <div class="issue-link-container">
          <a class="openjsfoundation-logo" href="https://openjsf.org/">
            <img src="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/openjs_foundation-logo.svg" alt="OpenJS Foundation" width="120" height="38">
          </a>
          <ul class="list-divider-pipe issue-link">
            <li><a href="https://github.com/nodejs/node/issues">Report Node.js issue</a></li>
            <li><a href="https://github.com/nodejs/nodejs.org/issues">Report website issue</a></li>
            <li><a href="https://github.com/nodejs/help/issues">Get Help</a></li>
          </ul>
        </div>
  
        <p>© OpenJS Foundation. All Rights Reserved. Portions of this site originally © Joyent.</p>
        <p>Node.js is a trademark of Joyent, Inc. and is used with its permission. Please review the <a href="https://trademark-list.openjsf.org/">Trademark List</a> and <a href="https://trademark-policy.openjsf.org/">Trademark Guidelines</a> of the <a href="https://openjsf.org/">OpenJS Foundation</a>.</p>
        <p>
          <a href="https://raw.githubusercontent.com/nodejs/node/master/LICENSE">Node.js Project Licensing Information</a>.
        </p>
  
        <div class="contributor-card">
          <a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#" rel="nofollow noopener noreferrer">
            <div class="spinner-border" role="status">
              <span class="sr-only">Loading...</span>
            </div>
            <img id="contributor-avatar" class="hidden" src="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/js-green.svg" alt="Avatar of a Node.js contributor" width="40" height="40">
          </a>
        
          <p>
            Thank you <a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#" id="contributor-username" rel="nofollow noopener noreferrer">username</a> for being a <a href="https://github.com/nodejs/node/graphs/contributors" rel="nofollow noopener noreferrer" title="List of all Node.js contributors">Node.js contributor</a>
            <a href="https://github.com/nodejs/node/graphs/contributors" rel="nofollow noopener noreferrer">
              <strong id="contributor-contributions">0 contributions</strong>
            </a>
          </p>
        </div>
  
      </div>
    </div>
  
  </footer>
  
  <script src="./Don&#39;t Block the Event Loop (or the Worker Pool) _ Node.js_files/main.js.download" async="" defer=""></script>


</body></html>